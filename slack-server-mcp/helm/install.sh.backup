#!/bin/bash

# Slack MCP Server Helm Chart Installation Script
# This script helps install the Slack MCP Server using Helm

set -e

# Configuration
CHART_NAME="slack-server-mcp"
NAMESPACE="${NAMESPACE:-mcp-servers}"
RELEASE_NAME="${RELEASE_NAME:-slack-server-mcp}"
VALUES_FILE="${VALUES_FILE:-}"
SECRET_NAME="${SECRET_NAME:-slack-server-mcp-secret}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."

    if ! command -v helm &> /dev/null; then
        log_error "Helm is not installed. Please install Helm first."
        exit 1
    fi

    if ! command -v kubectl &> /dev/null; then
        log_error "kubectl is not installed. Please install kubectl first."
        exit 1
    fi

    # Check if kubectl can connect to cluster
    if ! kubectl cluster-info &> /dev/null; then
        log_error "Cannot connect to Kubernetes cluster. Please check your kubeconfig."
        exit 1
    fi

    log_success "Prerequisites check passed"
}

# Create namespace if it doesn't exist
create_namespace() {
    if ! kubectl get namespace "$NAMESPACE" &> /dev/null; then
        log_info "Creating namespace: $NAMESPACE"
        kubectl create namespace "$NAMESPACE"
        log_success "Namespace created"
    else
        log_info "Namespace $NAMESPACE already exists"
    fi
}

# Collect Slack tokens and create secret
collect_tokens_and_create_secret() {
    log_info "Setting up Slack authentication..."

    # Check if secret already exists
    if kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" &> /dev/null; then
        log_warn "Secret '$SECRET_NAME' already exists in namespace '$NAMESPACE'"
        read -p "Do you want to update it? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "Using existing secret"
            return
        fi
        log_info "Updating existing secret..."
        kubectl delete secret "$SECRET_NAME" -n "$NAMESPACE"
    fi

    # Collect bot token
    echo
    log_info "Please provide your Slack Bot Token:"
    log_info "Get it from: https://api.slack.com/apps -> Your App -> OAuth & Permissions"
    log_info "It should start with 'xoxb-'"
    echo
    read -p "Slack Bot Token: " -r BOT_TOKEN
    echo

    # Basic validation
    if [[ ! $BOT_TOKEN =~ ^xoxb- ]]; then
        log_error "Bot token should start with 'xoxb-'. Please check your token."
        exit 1
    fi

    # Collect user token
    log_info "Please provide your Slack User Token:"
    log_info "Get it from: https://api.slack.com/apps -> Your App -> OAuth & Permissions"
    log_info "It should start with 'xoxp-'"
    echo
    read -p "Slack User Token: " -r USER_TOKEN
    echo

    # Basic validation
    if [[ ! $USER_TOKEN =~ ^xoxp- ]]; then
        log_error "User token should start with 'xoxp-'. Please check your token."
        exit 1
    fi

    # Create the secret
    log_info "Creating Kubernetes secret '$SECRET_NAME' in namespace '$NAMESPACE'..."
    kubectl create secret generic "$SECRET_NAME" \
        --from-literal=bot-token="$BOT_TOKEN" \
        --from-literal=user-token="$USER_TOKEN" \
        -n "$NAMESPACE"

    log_success "Secret created successfully"
}

# Create image pull secret for GHCR (only needed for private packages)
create_image_pull_secret() {
    log_info "Checking image accessibility..."

    # Check if secret already exists
    if kubectl get secret ghcr-pull-secret -n "$NAMESPACE" >/dev/null 2>&1; then
        log_info "Image pull secret already exists"
        return 0
    fi

    # Since the image is public, we don't need authentication
    log_info "The Docker image is publicly accessible - no authentication required"
    log_info "Skipping image pull secret creation"
    return 0

    # Legacy code below - kept for reference if image becomes private
    # Prompt for GitHub token
    echo
    echo "The Docker image is hosted on GitHub Container Registry (GHCR)."
    echo "To pull private images, you need a GitHub Personal Access Token with 'read:packages' scope."
    echo "Create one at: https://github.com/settings/tokens"
    echo
    read -p "Enter your GitHub Personal Access Token (or press Enter to skip): " GITHUB_TOKEN
    echo

    if [ -z "$GITHUB_TOKEN" ]; then
        log_warn "No GitHub token provided. Image pull may fail if the package is private."
        log_warn "You can make the package public at: https://github.com/bluefoxlabsai/bfl-mcp-servers/packages"
        return 1
    fi

    # Get GitHub username (optional, can use any string for username)
    read -p "Enter your GitHub username: " GITHUB_USERNAME
    if [ -z "$GITHUB_USERNAME" ]; then
        GITHUB_USERNAME="token"  # Default username for token auth
    fi

    # Create the secret
    kubectl create secret docker-registry ghcr-pull-secret \
        --docker-server=ghcr.io \
        --docker-username="$GITHUB_USERNAME" \
        --docker-password="$GITHUB_TOKEN" \
        --namespace="$NAMESPACE"

    log_success "Image pull secret created"

# Validate values file
validate_values() {
    if [ -n "$VALUES_FILE" ]; then
        if [ ! -f "$VALUES_FILE" ]; then
            log_error "Values file not found: $VALUES_FILE"
            exit 1
        fi
        log_info "Using values file: $VALUES_FILE"
    else
        log_warn "No values file specified. Using default values."
        log_warn "Make sure to set Slack tokens via --set or values file"
    fi
}

# Install Helm chart
install_chart() {
    log_info "Installing Slack MCP Server..."

    local helm_cmd="helm upgrade --install $RELEASE_NAME . \
        --namespace $NAMESPACE \
        --set slack.existingSecret=$SECRET_NAME"

    # Note: Image is public, no image pull secrets needed
    # (Legacy code kept for reference if image becomes private)
    # if kubectl get secret ghcr-pull-secret -n "$NAMESPACE" >/dev/null 2>&1; then
    #     helm_cmd="$helm_cmd --set imagePullSecrets[0].name=ghcr-pull-secret"
    # fi

    if [ -n "$VALUES_FILE" ]; then
        helm_cmd="$helm_cmd -f $VALUES_FILE"
    fi

    log_info "Running: $helm_cmd"
    eval "$helm_cmd"

    log_success "Slack MCP Server installed successfully"
}

# Wait for deployment to be ready
wait_for_deployment() {
    log_info "Waiting for deployment to be ready..."

    # Use label selector to find the deployment (more reliable than name)
    if kubectl wait --for=condition=available --timeout=60s \
        -l "app.kubernetes.io/name=slack-server-mcp,app.kubernetes.io/instance=$RELEASE_NAME" \
        deployment \
        -n "$NAMESPACE" 2>/dev/null; then
        log_success "Deployment is ready"
    else
        log_warn "Deployment is not ready yet. This may be due to image pull issues."
        log_warn "Check pod status: kubectl get pods -n $NAMESPACE"
        log_warn "Check pod logs: kubectl logs -f deployment/$RELEASE_NAME -n $NAMESPACE"
        log_warn "If image pull fails, you may need to:"
        echo "  1. Make the GHCR package public, or"
        echo "  2. Create an image pull secret for GHCR authentication"
        return 1
    fi
}

# Show post-installation information
show_post_install_info() {
    log_info "Post-installation information:"
    echo ""
    echo "1. Check the status of your deployment:"
    echo "   kubectl get pods -n $NAMESPACE"
    echo ""
    echo "2. Check the service:"
    echo "   kubectl get svc -n $NAMESPACE"
    echo ""
    echo "3. Check the secret:"
    echo "   kubectl get secret $SECRET_NAME -n $NAMESPACE"
    echo ""
    echo "4. View logs:"
    echo "   kubectl logs -f deployment/$RELEASE_NAME -n $NAMESPACE"
    echo ""
    echo "5. Test the health endpoint:"
    echo "   kubectl port-forward svc/$RELEASE_NAME 8080:8000 -n $NAMESPACE"
    echo "   curl http://localhost:8080/health"
    echo ""
    echo "6. Configure your MCP client to connect to:"
    echo "   http://$RELEASE_NAME.$NAMESPACE.svc.cluster.local:8000"
    echo ""
    echo "Available tools: post_message, search_messages, add_reaction,"
    echo "                 get_channel_info, get_user_info, list_channels,"
    echo "                 list_users, get_thread_replies, create_channel"
}

# Main installation function
main() {
    echo "Slack MCP Server Installation"
    echo "============================"
    echo ""

    check_prerequisites
    create_namespace
    collect_tokens_and_create_secret
    create_image_pull_secret
    validate_values
    install_chart
    wait_for_deployment
    show_post_install_info

    log_success "Installation completed successfully!"
    echo ""
    echo "üìã Summary of actions performed:"
    echo "  ‚úÖ Created namespace: $NAMESPACE"
    echo "  ‚úÖ Created secret: $SECRET_NAME (with bot-token and user-token)"
    echo "  ‚úÖ Installed Helm release: $RELEASE_NAME"
    echo "  ‚úÖ Deployment is ready and healthy"
    echo ""
    echo "üîó Service URL: http://$RELEASE_NAME.$NAMESPACE.svc.cluster.local:8000"
    echo "üè• Health check: http://$RELEASE_NAME.$NAMESPACE.svc.cluster.local:8000/health"
}

# Show usage
usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Install the Slack MCP Server using Helm"
    echo ""
    echo "This script will:"
    echo "  1. Create the Kubernetes namespace (if it doesn't exist)"
    echo "  2. Prompt for Slack Bot and User tokens"
    echo "  3. Create a Kubernetes secret with the tokens"
    echo "  4. Install the Helm chart using the secret"
    echo "  5. Wait for the deployment to be ready"
    echo ""
    echo "Options:"
    echo "  -n, --namespace NAMESPACE        Kubernetes namespace (default: mcp-servers)"
    echo "  -r, --release-name NAME          Helm release name (default: slack-server-mcp)"
    echo "  -s, --secret-name NAME           Kubernetes secret name (default: slack-server-mcp-secret)"
    echo "  -f, --values-file FILE           Path to additional values file"
    echo "  -h, --help                       Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0"
    echo "  $0 -n my-namespace"
    echo "  $0 -f helm/examples/values-dev.yaml"
    echo "  $0 -n my-namespace -r my-release -s my-secret"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        -r|--release-name)
            RELEASE_NAME="$2"
            shift 2
            ;;
        -s|--secret-name)
            SECRET_NAME="$2"
            shift 2
            ;;
        -f|--values-file)
            VALUES_FILE="$2"
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# Run main function
main
